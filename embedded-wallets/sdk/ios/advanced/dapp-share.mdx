---
title: Dapp Share
sidebar_label: Dapp Share
description: 'Web3Auth PnP iOS SDK - dapp share | Embedded Wallets'
---

## Embedded Wallets infrastructure at a glance

As described in the [Embedded Wallets infrastructure](/embedded-wallets/infrastructure/), to enable the non custodiality of Web3Auth, we split the private key into multiple parts, that is, into `shares`. These shares are a part of the offchain multisig, where multiple shares are stored in different places and can be used to reconstruct the private key dynamically in the user's frontend application. Typically, there are 3 shares:

1. **`ShareA` is managed by a login service via node operators:** This share is further split amongst a network of nodes and retrieved via conventional authentication flows.
2. **`ShareB` is stored on the user's device:** Implementation is device and system specific. For example, on mobile devices, the share could be stored in device storage secured via biometrics.
3. **`ShareC` is a recovery share:** An extra share to be kept by the user, possibly kept on a separate device, downloaded or based on user input with enough entropy (such as, password, security questions, hardware device).

Similar to existing 2FA systems, a user needs to prove ownership of at least 2 out of 3 (2/3) shares, in order to retrieve their private key. This initial setup provides several benefits.

## The user experience in mobile platforms

The user experience on mobile platforms is very different from the web platforms. This is because the user has to be redirected to a browser where they can login using their socials and then back to the app once they have been successfully authenticated. This user experience shifts the context between two applications, whereas, in the web platforms, the context remains within the browser only.

For the seamless login flow, we need to reconstruct the Shares `A` and `B`. `Share B` is managed by the login service and is provided on successful authentication. Whereas in web platforms, `Share A` is stored in the browser context. We can still store it in the browser context for mobile devices, but this has a few risks like users accidentally deleting browser data. This is a bigger problem in mobile devices since the user doesn't realize that the browser is being used to login within the app and clearing the browser data can cause their logins to fail. Hence, to tackle this issue, Web3Auth issues a dapp share, ie. a backup share that can be stored by the app developer directly within their application and used to reconstruct the private key after successful login by the user.

## Dapp share in iOS

Web3Auth issues a dapp share, ie. a backup share that can be stored by the app developer directly within their application and used to reconstruct the private key after successful login by the user.

After a successful login from a user, the user details are returned as a response to the application in mobile devices.

#### Sample response in iOS

```json
{
  "userInfo": {
    "email": "w3a-heroes@web3auth.com",
    "name": "Web3Auth Heroes",
    "profileImage": "https://lh3.googleusercontent.com/a/Ajjjsdsmdjmnm...",
    "verifier": "torus",
    "verifierId": "w3a-heroes@web3auth.com",
    "typeOfLogin": "google",
    "aggregateVerifier": "w3a-google-sapphire",
    "dappShare": "", // 24 words of seed phrase will be sent only in case of custom verifiers
    "idToken": "<JWT token issued by Web3Auth>",
    "oAuthIdToken": "<JWT token issued by OAuth provider>", // will be sent only in case of custom verifiers
    "oAuthAccessToken": "<Access token issued by OAuth provider>", // will be sent only in case of custom verifiers
    "isMfaEnabled": false // Returns whether the user has enabled MFA or not
  }
}
```

Notice, the reponses has a field called `dappShare` which is a 24 words seed phrase that can be used to reconstruct the private key. This dappShare is a suplement to the `Share A` and represents half of the private key. The application can store the dapp share in their own application local storage safely.

While logging in, the user can use their social accounts to obtain one share, and the application provides the dapp share, removing the need to store the share in the browser context and enabling user to login seamlessly. This can be done by passing over the stored dapp share value in the login function.

:::note

It's important to note that the `dappShare` is only available for custom verifiers and not the standard Web3Auth verifiers. This is done to make sure that an application only has access to the corresponding share to the private key of their application's user. Hence, to use dapp share, one has to use the custom authentication feature of Web3Auth. Also, the dapp share is only returned to users who have enabled 2FA to their account.

:::

```swift
Web3Auth().login(W3ALoginParams(loginProvider: provider, dappShare = "<24 words seed phrase>"))
```

## Example

```swift
import Foundation
import Web3Auth

class ViewModel: ObservableObject {
    var web3Auth: Web3Auth?
    @Published var loggedIn: Bool = false
    @Published var user: Web3AuthState?
    @Published var isLoading = false
    @Published var navigationTitle: String = ""

    func setup() async {
        guard web3Auth == nil else { return }
        await MainActor.run(body: {
            isLoading = true
            navigationTitle = "Loading"
        })
        web3Auth = await Web3Auth(W3AInitParams(
            clientId: clientId, network: network
        ))

        await MainActor.run(body: {
            if self.web3Auth?.state != nil {
                user = web3Auth?.state
                loggedIn = true
            }
            isLoading = false
            navigationTitle = loggedIn ? "UserInfo" : "SignIn"
        })
    }

    func login(provider: Web3AuthProvider) {
        Task {
            do {
                let result = try await web3Auth.login(
					W3ALoginParams(
                        // Provider can be .GOOGLE, .FACEBOOK, .APPLE etc
						loginProvider: provider,
						// focus-next-line
                        dappShare: "<24 words seed phrase>"
				))

                await MainActor.run(body: {
                    user = result
                    loggedIn = true
                })

            } catch {
                print("Error")
            }
        }
    }
}

```
