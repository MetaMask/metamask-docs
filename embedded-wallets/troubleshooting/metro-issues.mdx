---
title: Bundler polyfill issues - React Native Metro
image: 'img/metamaskog.jpg'
sidebar_label: React Native Metro polyfill issues
description: 'Bundler Polyfill Issues - React Native Metro | Embedded Wallets'
---

import TabItem from '@theme/TabItem'
import Tabs from '@theme/Tabs'

While setting up a new Web3 project from scratch, you might face bundler issues. This can occur because the core packages like `eccrypto` have dependencies which are not present within the build environment. 

To rectify this, the go-to method is to add the missing modules directly into the package, and edit the bundler configuration to use those. Although this approach works, it can significantly increase bundle size, leading to slower load times and a degraded user experience. 

Some libraries rely on environment-specific modules that may be available at runtime in the browser even if they are not bundled. Libraries such as Embedded Walletsâ€™ Web3Auth take advantage of this behavior and can function correctly without bundling all modules. However, if you are using a library that does not take advantage of this , you might face issues.

To avoid unnecessary overhead, include only the required polyfills, test functionality carefully, and configure your bundler to ignore unresolved modules rather than including them in the final build.

In this guide, we provide instructions for adding polyfills in React Native Metro. The steps demonstrate how to install the missing libraries required for module resolution and then configures Metro so they are not bundled unless needed at runtime.

## Step 1: Install the missing modules

Check for the missing libraries in your build and included packages, and polyfill these. For Web3Auth, you need to polyfill the `buffer`, `process`, `crypto` and `stream` libraries. For the rest of the libraries, we are installing a dummy module called `empty-module` which helps us get rid of the warnings while building the project.

```bash npm2yarn
npm install --save empty-module readable-stream crypto-browserify react-native-get-random-values buffer process
```

:::warning

There might be a possibility that you might need to polyfill more libraries, in case you're using any other blockchain library alongside Web3Auth that requires them. Generally, the libraries like `browserify-zlib`, `assert`, `stream-http`, `https-browserify`, `os-browserify`, `url` are the ones that might be required.

:::

## Step 2: Update your `metro.config.js`

To make use of the polyfilled modules while building the application, you need to reconfigure your metro bundler config.

:::info Expo-managed workflow

Create a `metro.config.js` for an expo-managed workflow, as it is not present by default. 

Learn more about [customizing a metro bundler](https://docs.expo.dev/guides/customizing-metro/).

Note that polyfilling is not supported with "Expo Go" app. It's compatible only with Custom Dev Client and Expo Application Services (EAS) builds. Please [prebuild your expo app](https://docs.expo.dev/workflow/prebuild/) to generate native code based on the version of expo a project has installed, before progressing.

:::

You can copy the following code in your `metro.config.js` file. This will tell the bundler to ignore the missing modules and include those that are needed.

#### `metro.config.js`

<Tabs
  defaultValue="bare"
  values={[
    { label: "Bare React Native", value: "bare" },
    { label: "Expo", value: "expo" },
  ]}
>
<TabItem value="bare">

```tsx title="metro.config.js"
const { getDefaultConfig, mergeConfig } = require('@react-native/metro-config')

const defaultConfig = getDefaultConfig(__dirname)

const config = {
  resolver: {
    extraNodeModules: {
      assert: require.resolve('empty-module'), // assert can be polyfilled here if needed
      http: require.resolve('empty-module'), // stream-http can be polyfilled here if needed
      https: require.resolve('empty-module'), // https-browserify can be polyfilled here if needed
      os: require.resolve('empty-module'), // os-browserify can be polyfilled here if needed
      url: require.resolve('empty-module'), // url can be polyfilled here if needed
      zlib: require.resolve('empty-module'), // browserify-zlib can be polyfilled here if needed
      path: require.resolve('empty-module'),
      crypto: require.resolve('crypto-browserify'),
      stream: require.resolve('readable-stream'),
    },
    sourceExts: [...defaultConfig.resolver.sourceExts, 'svg'],
  },
}

module.exports = mergeConfig(defaultConfig, config)
```

</TabItem>

<TabItem value="expo">

```tsx title="metro.config.js"
// Learn more https://docs.expo.io/guides/customizing-metro
const { getDefaultConfig } = require('expo/metro-config')

/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname)

config.resolver.extraNodeModules = {
  assert: require.resolve('empty-module'), // assert can be polyfilled here if needed
  http: require.resolve('empty-module'), // stream-http can be polyfilled here if needed
  https: require.resolve('empty-module'), // https-browserify can be polyfilled here if needed
  os: require.resolve('empty-module'), // os-browserify can be polyfilled here if needed
  url: require.resolve('empty-module'), // url can be polyfilled here if needed
  zlib: require.resolve('empty-module'), // browserify-zlib can be polyfilled here if needed
  path: require.resolve('empty-module'),
  crypto: require.resolve('crypto-browserify'),
  stream: require.resolve('readable-stream'),
  buffer: require.resolve('buffer'),
}

config.transformer.getTransformOptions = () => ({
  transform: {
    experimentalImportSupport: false,
    inlineRequires: true,
  },
})

module.exports = config
```

</TabItem>

</Tabs>

## Step 3: Fix additional dependency issues

1. Create a `globals.js` at your project root directory and add the following code to it:

  ```tsx title="globals.js"
  global.Buffer = require('buffer').Buffer

  // Needed so that 'stream-http' chooses the right default protocol.
  global.location = {
    protocol: 'file:',
  }

  global.process.version = 'v16.0.0'
  if (!global.process.version) {
    global.process = require('process')
    console.log({ process: global.process })
  }

  process.browser = true
  ```

2. Next, import the dependencies to `index.js` of your project.

:::info

For Expo apps, you need to create an entry point, that is, the index.js file. This can be done by following the steps [**here**](https://docs.expo.dev/versions/latest/sdk/register-root-component/#what-if-i-want-to-name-my-main-app-file-something-other-than-appjs)

:::

  <Tabs
    defaultValue="bare"
    values={[
      { label: "Bare React Native", value: "bare" },
      { label: "Expo", value: "expo" },
    ]}
  >
  <TabItem value="bare">

```tsx title="index.js"
import { AppRegistry } from 'react-native'
import './globals'
import 'react-native-get-random-values'
import App from './App'
import { name as appName } from './app.json'
AppRegistry.registerComponent(appName, () => App)
```

  </TabItem>

  <TabItem value="expo">

```tsx title="index.js"
import '@ethersproject/shims'
import '@expo/metro-runtime'
import 'react-native-get-random-values'
import './globals'

import { App } from 'expo-router/build/qualified-entry'
import { renderRootComponent } from 'expo-router/build/renderRootComponent'

// This file should only import and register the root. No components or exports
// should be added here.
renderRootComponent(App)
```

  </TabItem>

  </Tabs>
